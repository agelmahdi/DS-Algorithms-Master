
1. What is a graph?
  - Graph consists of a finite set of vertices or (Nodes) and a set of edges that connect a pair of nodes.

2. Graph Terminology
  A. Vertices are the node of the graph.
  B. Edge: is the line that connects pairs of vertices.
  C. Unweighted Graph:  A graph that does not have a weight associated with an edge.
  D. Weighted Graph:  A graph that has a weight associated with an edge.
  E. Undirected Graph:  In case the edges of the graph do not have a direction between them.
  F. Directed Graph:  In case the edges of the graph have a direction between them.
  G. Cyclic Graph:  a graph that has a least one loop.
  H. Acyclic Graph:  a graph that has no loop.
  I. Tree: This is a special case of a directed acyclic graph.

3. Graph Types:

                           Graph
                         /         \
                        /           \
                       /             \
                  Directed          Undirected
                  /    \              /    \
                 /      \            /      \
                /        \          /        \
            Weighted  Unweighted  Weighted Unweighted
             /    \                /    \
            /      \              /      \
           /        \            /        \
      Positive    Negative    Positive  Negative



   A.Unweighted - Undirected: No weight associated with any edges, No direction between edges

               V1 - - -V3
               |\       \
               | \       \
               |  \       \
               |   \      V5
               |    \     /
               |     \   /
               |      \ /
               V2- - - V4
   B.Unweighted - Directed: No weight associated with any edges, there is a direction between edges

                V1 - - ->V3
                ^ ^        ^
                |  \        \
                |   \        \
                |    \       V5
                |     \      ^
                |      \    /
                |       \  /
                V2- - -> V4
   C.Positive - weighted - Undirected: there is a positive weight associated with edges, No direction between edges

                    5
               V1 - - -V3
               |\       \
               | \       \ 1
               |  \       \
             2 |   \ 4     V5
               |    \     /
               |     \   / 7
               |      \ /
               V2- - - V4
                   3
   D.Positive - weighted - Directed: there is a positive weight associated with edges, there is a direction between edges

                      5
                 V1 - - -> V3
                 ^ ^        ^
                 |  \        \ 1
                 |   \        \
                 |    \ 4     V5
                2|     \      ^
                 |      \    /
                 |       \  / 7
                 V2- - -> V4
                      3
   E.Negative - weighted - Undirected: there is at least a negative weight associated with edges, No direction between edges

                    -5
                V1 - - -V3
                |\       \
                | \       \ 1
                |  \       \
              2 |   \ -4    V5
                |    \     /
                |     \   / 7
                |      \ /
                V2- - - V4
                    3
   F.Negative - weighted - Directed: there is at least a negative weight associated with edges, there is a direction between edges

                       -5
                  V1 - - -> V3
                  ^ ^        ^
                  |  \        \ 1
                  |   \        \
                  |    \ -4    V5
                 2|     \      ^
                  |      \    /
                  |       \  / 7
                  V2- - -> V4
                       3

 4. Graph representation
   A. Adjacency matrix: an adjacency matrix is a square matrix or 2D array. and the elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.

                                             _A_ _B_ _C_ _D_ _E_
                   A - - - B               A|_0_|_1_|_1_|_1_|_0_|
                   |\       \              B|_1_|_0_|_0_|_0_|_1_|
                   | \       \             C|_1_|_0_|_0_|_1_|_0_|
                   |  \       \            D|_1_|_0_|_1_|_0_|_1_|
                   |   \       E           E|_0_|_1_|_0_|_1_|_0_|
                   |    \     /
                   |     \   /
                   |      \ /
                   C- - -  D

   B. Adjacency List is a collection of unordered lists used to represent a graph. Each list describes the set of neighbors of a vertex in the graph.

                      A - - - B               |_A_|->|_B_|_|->|_D_|_|->|_C_|_|
                      |\       \              |_B_|->|_A_|_|->|_E_|_|
                      | \       \             |_C_|->|_A_|_|->|_D_|_|   _ _ _
                      |  \       \            |_D_|->|_A_|_|->|_C_|_|->|_E_|_|
                      |   \       E           |_E_|->|_B_|_|->|_D_|_|
                      |    \     /
                      |     \   /
                      |      \ /
                      C- - -  D

   -> When to use?
     A. Adjacency matrix: if the graph is complete or almost complete which means all cells have 1's.
     A. Adjacency List: if the number of edges is few then we should use Adjacency List.

 5. Graph traversal: it is a process of visiting all vertices in a given graph,

   A. Breadth-first search: it starts at some arbitrary node of a given graph and explores the neighbor's nodes that are "at the current level", before moving to the next node.
       -> When to use?
        - if we know that the target vertex is close to the starting point.
       -> Pesudocode

          while all vertices are not explored -------->O(v) -----------------------------------------------------------
           enqueue any starting vertices ------>O(1)                                                                   |
           while queue is not empty -------->O(ver) ----------------------                                             |-> Time and space complexity = O(V+E)
            p = dequeue() ------>O(1)                                     |                                            |
            if p is unvisited ------>O(1)                                 |-> vertices + adjacent = edges = O(edges)---
              mark as visited ------>O(1)                                 |
              enqueue unvisited adjacent vertices of p ------>O(adj)------


   B. Depth-first search: it starts at some arbitrary node of a given graph, and explore as far as possible along each edge before backtracking.
       -> When to use?
        - if we know that the target vertex is buried very deep.
       -> Pesudocode

          while all vertices are not explored -------->O(v) -----------------------------------------------------------
           push any starting vertices ------>O(1)                                                                      |
           while stack is not empty -------->O(ver) ----------------------                                             |-> Time and space complexity = O(V+E)
            p = pop() ------>O(1)                                         |                                            |
            if p is unvisited ------>O(1)                                 |-> vertices + adjacent = edges = O(edges)---
              mark as visited ------>O(1)                                 |
                push unvisited adjacent vertices of p ------>O(adj)---------


 6. Topological sort: sorts a given action in such a way that if there is a dependency of one action on another, then the dependant action always comes later than its parent action.
       -> Pesudocode

          topoSort(Node,Stack)____________
           for all vertices               |
             if vertex unvisited          |-> O(V) ---------
                topoVisited(vertex)_______|                 |
                                                            |
          topoVisited(node, stack)---------                 | -> Time and space complexity = O(V+E)
           for each nodes                  |                |
             if unvisited                  |-> O(E)---------
               topoVisited(neighbor)       |
           stack.push(neighbor)------------

 7. Single source shortest path problem "SSSPP": it is about finding the path between a given vertex "source" to all other vertices in a graph such that
                                           the total distance between them "source and destination" is minimum.

       -> solve this problem using three types of algorithms

         A. Breadth first search algorithm:

             -> When to use?
              -Unweighted - undirected
              -Unweighted - directed

             -> Why DFS not a working solution?
              -DFS has the tendency to go "as far as possible" from source, hence it can never find the shortest path

             -> Pesudocode

                   enqueue any starting vertices ------>O(1) ----------------------
                    while queue is not empty -------->O(ver)                       |
                     current = dequeue() ------>O(1)                               |-> Time complexity = O(E)
                     if current is unvisited ------>O(1)                           |
                       mark as visited ------>O(1)                                 |-> Space complexity = O(V)
                       update parent of adjacent vertices to current               |
                       enqueue unvisited adjacent vertices of current->O(adj)------


         B. Dijkstra's algorithm:
             -> When to use?
               -Positive - weighted - directed

             -> When not working?
               - with negative Cycle: a cycle is a path of edges or vertices wherein a vertex is reachable from itself, and the total weight of the cycle is a negative number.

         C. Bellman Ford algorithm
