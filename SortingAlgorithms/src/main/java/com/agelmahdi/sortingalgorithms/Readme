
 1. What is sorting?
  - by definition sorting refers to arranging data in a particular format: either ascending or descending

 2. types of sorting

                           Sorting
                         /         \
                        /           \
                       /             \
                Space used           Stability
                  /    \              /    \
                 /      \            /      \
                /        \          /        \
            in space  out space   Stable    Unstable

   A. Space Used

    - In Space sorting: sorting algorithms which does not require any extra space for sorting.
     Ex-> Bubble sort, Selection sort

    - Out Space sorting: sorting algorithms that require extra space for sorting.
     Ex-> Merge sort

   B. Stability

    - Stable sorting: if a sorting algorithm after sorting does not change the sequence of the similar content in which they appear in the original one.
     Ex-> Insertion sort

    - Unstable sorting: if a sorting algorithm after sorting changes the sequence of the similar content in which they appear in the original one.
     Ex-> Quick sort

 3. Sorting terminology

     - Increasing order: if the successive element is greater than the previous one.
       Ex-> 1, 3, 5, 7, 9, 11

     - Decreasing order: if the successive element is less than the previous one.
       Ex-> 11, 9, 7, 5, 3, 1

     - Non-Increasing order: if the successive element is Less than or Equal to its previous element in the sequence.
       Ex-> 11, 9, 7, 5, 5, 3, 1

     - Non-Decreasing order: if the successive element is Greater than or Equal to its previous element in the sequence.
       Ex-> 1, 3, 5, 7, 7, 9, 11

 4. Sorting algorithms

   A. Bubble Sort: referred also as Sinking sort in which Repeatedly compare each pair of adjacent items and swap them if they are in the wrong order.
     -> When to use?
      - The input is almost sorted
      - Space is a concern
      - Easy implementation

     -> When to avoid?
      - Average time complexity is poor.

  B. Selection Sort: Repeatedly find the minimum element and move it to the sorted part of the array to make the unsorted part sorted.
     -> When to use?
      - We have insufficient memory
      - Easy implementation

     -> When to avoid?
       - Time is a concern.

   C. Insertion Sort:
     A. Divide the given array into two parts,
     B. then, take the first element from the unsorted array and find the correct position in the sorted array,
     C. then, repeat until the unsorted array is empty.

      -> When to use?
       - We have a continuous inflow of numbers and we want to keep them sorted.
       - We have insufficient memory.
       - Easy implementation.

      -> When to avoid?
       - Time is a concern.

   D. Bucket Sort:
     A. Create buckets and distribute elements of the array into buckets
     b. Sort the buckets individually
     c. Merge buckets after sorting

      -> When to use?
       - The Input uniformly distributed with small differences between numbers -> like 1,3,4,6,7,8,10,8,9

      -> When to avoid?
       - Space is a concern.

   E. Merge Sort:
     A. is a divide and conquer algorithm
     B. Divide the input array into two halves and we keep halving recursively until they become too small that cannot be broken further
     C. Merge halves by sorting them

      -> When to use?
       - Stable sort is required.
       - Average expected time O(n log(n)).

      -> When to avoid?
       - Space is a concern.

   F. Quick Sort: Preferred over other sorting algorithms
    A. Is a divide and conquer algorithm.
    B. Find the pivot number and make sure smaller numbers are located at the left of pivot and the bigger numbers are located at the right of the pivot.
    C. Unlike merge sort extra space not required.

     -> When to use?
      - Average expected time O(n log(n)).

     -> When to avoid?
      - Space is a concern.
      - Stable sort is required.

   H. Heap Sort :
    A. Step#1: Insert data to binary heap
    B. Step#2: Extract data from binary heap
    C. it is best suitable with array rather than linked list

 5. Algorithm priority selection:

   A. Stability.
   B. Space Efficient.
   C. Time Efficient.
